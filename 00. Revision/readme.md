# Преговор на материала от курса по УП

Ще наблегнем основно върху функции, указатели, референции, низове и динамична памет.

## Задача 01

Да се напише функция, която приема масив от реални числа
и *връща* минималния и максималния елементи в масива.

Пример:

```cpp
double arr[]{5,-1,0.3,7,1};
// ~> min: -1,  max: 7
```

## Задача 02

Да се напише програма, която чете низ с максимална дължина 1024 символа
от стандартния вход и обръща всички думи в низа.

Пример:

```cpp
// Вход:
"i hate fmi ):"

// Изход:
"i etah imf :)"
```

Реализирайте горното по два начина - използвайки само индекси и използвайки само указатели.

## Задача 03

RLE (Run Length Encoding) е начин за кодиране на множество последователни срещания
на елементи в някаква редица. Например, низът `"aabcccdaa"` може да се запише като
`"a2b1c3d1a2"`, където всеки символ се следва от броя му последователни срещания.
Да се напише програма, която чете цяло неотрицателно число `k` от стандартния вход,
след което чете низ с дължина, не по-голяма от `k`, представяща RLE низ.
Да се провери дали съществува индекс `i` в **декодирания** низ `decoded`, така че
сумата от ASCII кодовете на символите в `decoded[0..i]` да бъде равна на сумата
от ASCII кодовете на символите в `decoded[i+1..n-1]`, където `n` е дължината на низа.

## Задача 04 (за домашно)

Да се напише програма, която чете две числа от стандартния вход,
представящи съответно брой редове и брой колони на матрица от символи,
след което се прочитат елементите на тази матрица. Най-накрая се чете низ `s`
с максимална дължина 128 символа. Да се провери дали съществуват такива
координати `(x,y)` в матрицата `matrix`, така че, започвайки от клетката
`matrix[x][y]`, низът `s` да може да бъде образуван изцяло чрез движения нагоре,
надолу, наляво или надясно между съседни клетки. Ако такава клетка съществува,
да се върнат нейните координати.

Разгледайте три варианта за имплементация на горната функция, като:

- не са позволени повторения на координати на елементи в матрицата;
- не са позволени повторения на един и същи символ. Тъй като е възможно
  в самата матрица да има координати `(x1,y1)` и `(x2,y2)` с `matrix[x1][y1] == matrix[x2][y2]`
  така че `(x1,y1) != (x2,y2)`, не бихме искали да повтаряме даден символ повече от един път.

За някой от трите варианта да се модифицира функцията, така че да се пази информация за
направените движения, след което, ако такъв път съществува, да се изведе на стандартния изход
пътят, форматиран по някакъв начин. Например:

**Вход:**
```cpp
[ ['a', 'b', 'f', 'v']
, ['c', 'i', 'm', 'd']
, ['l', 't', 'i', 'o'] ]
"fmi"  // търсеният низ
```

**Изход:**
```cpp
Start: (0,2)
Moves: down -> down
```
