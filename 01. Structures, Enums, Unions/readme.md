# Структури, изброими типове, обединения

Досега сме използвали само вградените в C++ типове - `int`, `char`, `double *`, `void` и др.
Сами по себе си тези типове невинаги са достатъчно описателни за нашите цели -
понякога бихме искали да използваме крайно множество от естествени числа,
като всяко число кодира някакъв по-абстрактен обект (напр. можем да представим
всеки от сезоните с някакво цяло число, като числата за 4-те сезона са последователни);
в други ситуации бихме искали да опишем някакъв "обект" на база множество от свойства,
които този обект притежава (напр. всеки човек има свое име и възраст); а понякога
даже бихме искали да можем да разгледаме един и същи обект през няколко различни призми.

Ще видим, че по-горе изброените могат да се симулират и в програмните езици,
и в частност в C++.

Всички от следните конструкции в C++ **дефинират нови типове**.
Всяка от тези конструкции може да бъде дефинирана в каквато и да е
област, т.е. може да бъде глобална, може да бъде локална за някаква
функция или друга структура и др.

В следващите няколко раздела ще приемаме, че `sizeof(int) == 4`,
`sizeof(unsigned int) == 4`, `sizeof(float) == 4`.

## Изброими типове (enums)

Изброимите типове (енумерации) ни предоставят начин за създаване на тип
и крайно множество от стойности от този тип, като дадена променлива
винаги съдържа **точно една** от тези стойности.

Синтаксисът за дефиниране на изброим тип в C++ е следният:

```c++
enum {<име_на_тип>} {
  <име_на_стойност_1>,
  <име_на_стойност_2>,
  // ...
  <име_на_стойност_n>
} {<променливи_от_този_тип>};
```

Например, можем да дефинираме изброим тип за годишен сезон по следния начин:

```cpp
enum Season {
  WINTER,
  SPRING,
  SUMMER,
  AUTUMN
};
```

Разбира се, съвсем естествено е да моделираме сезоните чрез изброим тип -
все пак няма как едновременно да се намираме в два годишни сезона.
Очевидно този тип има 4 възможни стойности (1 + 1 + 1 + 1 = 4
за всяка стойност, представяща сезон).

```cpp
Season s = get_current_season();
switch (s) {
  case WINTER: std::cout << "winter\n"; break;
  case SPRING: std::cout << "spring\n"; break;
  case SUMMER: std::cout << "summer\n"; break;
  case AUTUMN: std::cout << "autumn\n"; break;
}
```

### Представяне

Стойностите в изброимите типове са от някакъв интегрален тип, като това
е implementation-dependent и зависи от компилатора. Обикновено обаче се използва `int`.
Тоест, ако този тип е `int`, то за някоя стойност на енумерацията по-горе е изпълнено:

```cpp
sizeof(WINTER) == sizeof(int)
```

Това не е случайност. В действителност имплементацията на изброимите типове
в C++ използва именно целочислени стойности (освен ако не е указано друго,
това ще го видим малко по-надолу). Следователно е напълно възможно да преобразуваме
дадена стойност на изброим тип до стойност от типа, чрез който е представена вътрешно
(в нашия случай - `int`):

```cpp
std::cout << static_cast<int>(WINTER) << '\n';  // 0
std::cout << static_cast<int>(SPRING) << '\n';  // 1
std::cout << static_cast<int>(SUMMER) << '\n';  // 2
std::cout << static_cast<int>(AUTUMN) << '\n';  // 3
```

По подразбиране, ако не просвоим някаква конкретна целочислена стойност
на стойност `x` в енумерацията, то тези `x`-ове се индексират последователно в реда
им на дефиниция, и именно затова получаваме горното поведение.

**Въпрос**: Какво би се случило с горния кодов фрагмент, ако напишем следното:

```cpp
enum Season {
  WINTER,
  SPRING = 4,
  SUMMER = 8,
  AUTUMN
};
```

Възможно е да променим типа на стойностите, чрез които се представят
тези в дадена енумерация:

```cpp
// след : типът винаги трябва да бъде интегрален,
// т.е. да се представя чрез цяло число
enum Season : size_t {
  ...
};
```

Тогава би било изпълнено `sizeof(size_t) == sizeof(WINTER) == ... == sizeof(AUTUMN)`.

**Въпрос**: Защо следното е невалидно?

```cpp
enum Season : double {
  ...
};
```

### Брой стойности на изброим тип

Естествено е да поискаме да проверим колко на брой различни стойности
има в даден изброим тип. Бихме могли да се позовем на знанията си за
масивите в C++ и действието на оператора `sizeof`, когато аргументът му е масив,
и да заключим, че големината на енумерация е броят на стойностите в нея (потенциално разделена на някаква константа):

```cpp
sizeof(Season); // каква стойност би върнало?
```

В общия случай горното би върнало резултат 4. Супер, изглежда вече знаем как да
намираме броя стойности на даден изброим тип. Нека сега си дефинираме енумерация
за дните в седмицата:

```cpp
enum DayOfTheWeek { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY };
```

Очевидно `sizeof(DayOfTheWeek) == 7`, все пак имаме 7 възможни стойности!

Ако изпълним горното обаче, ще забележим нещо странно: това отново връща резултат 4!

Истината е, че нямаме достатъчно елегантен начин за намиране броя на стойности,
които се съдържат в даден изброим тип. Причината е, че `sizeof(<enum_type>)` в действителност
връща големината на стойност в енумерацията (забележете, че всичките стойности са с еднакви големини!).
Това е очаквано поведение, тъй като в даден момент можем да имаме или първата стойност от енумерацията,
или втората стойност, и така нататък. Тогава следната верига от равенства е вярна:

```cpp
sizeof(DayOfTheWeek) == sizeof(MONDAY) == ... == sizeof(SUNDAY)
```

Тогава, ако искаме да преброим броя възможни стойности, имаме два основни варианта:

- hardcode-ваме броя стойности директно. Това би означавало да направим следното нещо:

  ```cpp
  constexpr unsigned SEASONS = 4;
  ```

- добавяме фиктивна стойност **в края** (това е ключово!):

  ```cpp
  enum Season {
    WINTER,
    SPRING,
    SUMMER,
    AUTUMN,
    END
  };
  ```

  Да си припомним, че при липса на инициализация на стойност от енумерацията
  по подразбиране тези стойности се индексират от 0 в реда на дефинирането им.
  Това означава, че индексът на `END` (или цялото число, което съответства на тази стойност)
  е именно 4 - колкото е броят на *същинските* стойности.

### Анонимни енумерации

Енумерациите могат да бъдат и анонимни - т.е. при дефиницията им не указваме име на тип.
Например, щеше да е валидно да напишем:

```cpp
enum {
  RED,
  GREEN,
  BLUE
};
```

Но това ни ограничава в някои аспекти, тъй като вече нямаме конкретен тип,
който да използваме, за да реферираме стойностите `RED`, `GREEN`, `BLUE`,
така че те просто се третират като `int` стойности (освен ако в имплементацията
на компилатора не се използва друг туп или не е указано друго).

Забележете, че в горната анонимна енумерация `RED`, `GREEN` и `BLUE` са
**compile-time константи** (стойностите им се знаят по време на компилация
и не можем да ги променяме):

```cpp
RED = 1;
```

```cpp
~> error: lvalue required as left operand of assignment
```

### Проблеми с пространството на имената - `enum class`

Нека си представим, че искаме да дефинираме константата `WINTER`,
която просто съдържа низа `"winter"`. Ако напишем следното:

```cpp
enum Season {...};  // стойностите от по-горе
constexpr char const *WINTER = "winter";
```

Ще получим компилационна грешка:

```cpp
error: ‘constexpr const char* const WINTER’ redeclared as different kind of entity
```

Това се случва именно защото по подразбиране стойностите в енумерациите, дефинирани в глобалното пространство
на имената, също имат глобална видимост. Горният случай бихме могли да избегнем чрез преименуването на стойността
в изброимия тип или чрез преименуването на низа. Но в общия случай това не е много добра практика, тъй като на даден
етап вероятно ще започнем да пишем сравнително криптични имена на променливи/константи просто за да избегнем горната ситуация.
Затова ще въведем още един вид енумерация, където по подразбиране стойностите имат своя собствена област на видимост:

```cpp
enum class Season2 { // двойките са с демонстративна цел, моля не си кръщавайте нещата така
  WINTER2,
  SPRING2,
  SUMMER2,
  AUTUMN22
};
```

Тогава вече няма да може да напишем следното:

```cpp
Season2 s = get_current_season();
switch (s) {
  // невалидно! стойностите не са видими по този начин
  case WINTER2: std::cout << "winter\n"; break;
  case SPRING2: std::cout << "spring\n"; break;
  case SUMMER2: std::cout << "summer\n"; break;
  case AUTUMN2: std::cout << "autumn\n"; break;
```

Тогава, за да "влезем" в областта, в която са видими горните стойности,
трябва да напишем `Season2::WINTER2`, `Season2::SPRING2` и т.н.
Операторът `::` се нарича оператор за принадлежност - стойностите `WINTER2`, `SPRING2`
и др. *принадлежат* на пространството от имена на `Season2`.

Друга разлика с `enum` е, че `enum class` не позволява неявното преобразуване
на стойности до стойности от тип `int`.

---

## Структури (structures, records)

Структурите са начин за обединяването на няколко
типа данни в един по-голям тип данни. Синтаксисът за дефиниране е следният:

```cpp
struct <име_на_структура> {
  // поле_1
  // поле_2
  // ...
  // поле_n
} {<имена_на_обекти>};
```

Например, за да дефинираме тип `Student`, който съдържа информация
**едновременно** за името, възрастта и факултетния номер на даден студент,
бихме написали следното:

```cpp
struct Student {
  char name[129];
  unsigned age;
  char fn[11];
};
```

`name`, `age` и `fn` се наричат *полета* или *член-данни* на структурата.

За да създадем някакъв студент, използваме името на типа, което сме използвали при дефиниция
на структурата:

```cpp
// дефиниция на обект без инициализация
Student s1;
```

`s1` се нарича *обект* или *инстанция* на структурата `Student`.

Съответно можем да достъпваме всяко от полетата на обект на структура, като използваме оператора `.`:

```cpp
std::cout << s1.name << '\n';
std::cout << s1.age  << '\n';
std::cout << s1.fn   << '\n';
```

**Ключово за обектите, дефинирани и създадени по горния начин, е, че техните полета остават
неинициализирани и достъпването на неинициализирани полета е недефинирано поведение.**

*Забележка*: Разбира се, има и изключение към това правило. Ако променливата `s1` е дефинирана глобално,
то нейните полета се инициализират със стойностите си по подразбиране **винаги**. Това не е вярно само
за обекти, а за всички глобално дефинирани променливи (и константи, макар че те винаги трябва да бъдат неинициализирани
с някаква стойност *ръчно*).

Ще разгледаме два по-основни начина (има и други!) за инициализиране на полетата на обекти на структура:

- след създаването на обект:

  ```cpp
  Student s1;
  // забележете, че операторът . е с по-висок приоритет от
  // оператора за индексиране!
  s1.name[0] = 'a'; s1.name[1] = 'b'; s1.name[2] = 'c';
  s1.name[3] = '\0'; // това е важно!

  s1.age = 20;

  // помислете как работи този цикъл
  for (char n = '0'; n <= '9'; ++n)
    s1.fn[n - '0'] = n;
  ```

  Разбира се, горното е възможно дори ако полетата на обекта са били инициализирани
  преди това, и съответства на промяна на тези полета.

- със създаването на обект (дефиниция с инициализация):

  За целта се използва т.нар. инициализиращ списък `{...}`, който сме виждали
  при инициализацията на елементите на някакъв масив (напр. `int arr[]{1,2,3};`):

  ```cpp
  Student s1{"some name", 20, "0123456789"};
  ```

Имаме и т.нар. designated initialisation, чрез която инициализираме полетата
на някаква структура, като екплицитно пишем полето, което искаме да инициализираме.
Забележете, че полетата отново трябва да се срещат в реда, в който са дефинирани в структурата
(най-долу може да видите пример, където *трябва* да използваме този синтаксис):

```cpp
Student s{ .name = "some name", .age = 20, .fn = "0123456789" };
```

### Обекти като параметри на функции

Нека разгледаме следната функция, която приема като параметър някакъв студент
и извежда полетата му на стандартния изход:

```cpp
// (1)
void print(Student s) {
  std::cout << s.name << '\n';
  std::cout << s.age  << '\n';
  std::cout << s.fn   << '\n';
}
```

Сама по себе си тази функция работи коректно, но е неоптимална. Причината е
начинът, по който подаваме обектите от тип `Student` - подаваме ги по стойност,
което означава, че в най-лошия случай ще направим копие на обекта, който подаваме.
Такова копие може да е сравнително скъпо в зависимост от това, какви полета има обектът.
За да избегнем това, **почти винаги** (а в началото - винаги) ще подаваме обектите по референция:

```cpp
void print(Student const &s) {...}
```

*Допълнително*: За функция от вида `(1)` е невинаги вярно, че ще направим копие
на обекта, който подаваме като параметър, което ще видим по-напред в курса в лицето
на компилаторната оптимизация *избягване на копиране* (copy elision) и т.нар.
семантики за преместване (move semantics).

### Указатели към обекти

На даден етап може да ни се наложи да използваме *указател* към обект от някакъв тип.
За да можем да работим с такъв обект, **първо винаги трябва да проверим дали указателят
не е `nullptr`** (и не само в контекста на обекти). Ако той е различен от `nullptr`,
то най-вероятно бихме искали да достъпваме полетата на този обект по някакъв начин:

```cpp
void print(Student const *s) {
  if (!s) return;
  // първо деференцираме обекта, като трябва да го заградим в скоби,
  // понеже унарният оператор * е с по-нисък приоритет от .
  std::cout << (*s).name << '\n';
  // операторът -> е синтактична захар за горното
  std::cout << s->age    << '\n';
  // ще използваме основно този синтаксис, понеже е по-четим
  std::cout << s->fn     << '\n';
}
```

Операторът `->` съответства на деференцирането на указател към обект и достъпването
на някакво негово поле с оператора `.`. Забележете, че ако указателят е `nullptr`,
ще имаме недефинирано поведение, независимо кой от двата начина за достъпване на поле използваме.

### Представяне в паметта

Както с всеки друг съставен тип данни, бихме искали да проверим колко е размерът
на структурата, дефинирана по-горе. Тя съдържа 3 полета, така че очевидно бихме се
опитали да сумираме големините на всички от тях, за да получим големината на обект
от структурата. И така - 129 + 4 + 11 = 144.

Ако се опитаме да проверим големината на горната структура, обаче, ще забележим,
че действителната ѝ големина не е това, което ние пресметнахме:

```cpp
sizeof(Student) == 148
```

В действителност полетата на обект на дадена структура се *подравняват* по определени правила,
в които имат значение най-големият размер на тип на някое от полетата и редът, в който полетата
са дефинирани в класа (отгоре на долу). За да пресметнем големината на дадена структура,
изпълняваме следните стъпки:

- намираме най-голямото подравняване на някое от полетата на класа. Това подравняване
  можем да вземем, използвайки оператора `alignof(<тип>)`. Забележете, че при масиви
  подравняването зависи само и единствено от подравняването на елементите в масива
  (в зависимост от техния тип), а не - от броя на елементите в масива. Тъй като в
  `Student` имаме данни от общо два различни типа, където `alignof(char) == 1`
  и `alignof(unsigned) == 4`, то най-голямото такова
  подравняване е 4, така че и подравняването на самата структура е 4, т.е.
  `alignof(Student) == 4`. Забележете, че в общия случай за тип T
  (и оттам - потребителските дефинирани такива, каквито са структурите)
  не е вярно, че `alignof(T) == sizeof(T)`. Ако имаме вложени обекти, напр.
  някакъв потребителски дефиниран тип `B` като поле на друг потребителски дефиниран тип `A`,
  то при пресмятането подравняването на `A` се взима предвид `alignof(B)`, а не - `sizeof(B)`.
  Разбира се, това, че `B` е потребителски дефиниран тип не означава, че винаги неговото подравняване
  определя `alignof(A)`, възможно е да има друго поле с по-голямо подравняване;

- последователно подреждаме данните от полетата на структурата, като всяка "данна"
  се намира на адрес, който е кратен на нейното подравняване (`alignof(<тип>)`).
  Може да се получи така, че да има "празно място" между няколко различни данни.
  Тези празни места също участват при пресмятането размера на структурата и се наричат
  *padding* (не знам дали има хубава дума на български за това :(, а подравняване
  очевидно означава съвсем друго нещо);

- големината на цялата структура е число, което е винаги кратно на подравняването на
  структурата, което съвпада с най-голямото подравняване на някое от полетата. 
  Например, `sizeof(Student) == 148` и `alignof(unsigned int) == 4`
  като 4 дели 148. Това означава, че може да се наложи да се добавят допълнителни "празни"
  (т.е. не съдържат някаква съществена информация) клетки след последната съществена "данна"
  от структурата - това също е padding.

Нека си фиксираме обект, инициализиран по следния начин:

```cpp
Student s{"nico", 21, "0123456789"};
```

Големината на този обект е 148 байта, като подравняването му е 4.
С цел прегледност ще представяме паметта като последователност от
редове с по 4 колони (в действителност всички тези данни са последователни
в паметта, но иначе диаграмата би била прекалено дълга). Първата клетка във
всеки ред се намира на адрес в паметта, който е кратен на подравняването.
За представянето на клетките, които представляват padding, ще използваме диез (`#`). 
В паметта разположението на данните би изглеждало
по следния начин (ще броим байтовете от 0, но това няма особено значение,
тъй като е просто с илюстративна цел и за наше удобство):

<pre style="font-family: monospace; line-height: 1.2;">
┌───┐┌───┐┌───┐┌───┐
│'n'││'i'││'c'││'o'│  // байтове 0-3, начало на полето name
└───┘└───┘└───┘└───┘
┌───┐┌───┐┌───┐┌───┐
│\0 ││\0 ││\0 ││\0 │  // байтове 4-7, представете си, че има единични кавички, нямам място за тях
└───┘└───┘└───┘└───┘
        ...
┌───┐┌───┐┌───┐┌───┐
│\0 ││ # ││ # ││ # │  // байтове 128-131, последният байт от name е 129-ти подред
└───┘└───┘└───┘└───┘
┌───┐┌───┐┌───┐┌───┐
│15 ││00 ││00 ││00 │  // байтове 132-135, начало на полето age
└───┘└───┘└───┘└───┘
┌───┐┌───┐┌───┐┌───┐
│'0'││'1'││'2'││'3'│  // байтове 136-139, начало на полето fn
└───┘└───┘└───┘└───┘
┌───┐┌───┐┌───┐┌───┐
│'4'││'5'││'6'││'7'│  // байтове 140-143
└───┘└───┘└───┘└───┘
┌───┐┌───┐┌───┐┌───┐
│'8'││'9'││\0 ││ # │  // байтове 144-147
└───┘└───┘└───┘└───┘
</pre>

*Забележка*: Полето `age` е от тип `unsigned int`, т.е. големината 4 байта в общия случай,
така че байтове 132-135 представят именно него. Всеки байт е записан посредством
шестнадасетично число (за удобство). Байтовете са записани "наобратно" (т.е.
в началото, на най-ниския адрес, се намира най-младшият байт), тъй като сме използвали
т.нар. малък байтов ред (не гарантирам, че това е точният превод), по-познат като
little endian layout. Със същия успех можехме да използваме и big endian layout,
това нямаше да има значение за разположението на полетата в паметта.

**Редът на дефиниране на полетата има значение за големината на структурата**.
За упраженение разменете полетата на `Student` по такъв начин, че да получите минимален
размер на структурата и нарисувайте разположението на данните в паметта, подобно на горната схема.

*Забележка*: На семинар (КН1) бях казала, че горната структура за `Student` има размер 146,
което щеше да е вярно, ако `age` беше от тип `unsigned short`, тъй като `sizeof(unsigned short) == 2`.
Но тъй като тогава използвахме `unsigned int`, получихме, че размерът е 148. Ето как би изглеждало представянето
на `Student` в паметта, ако `age` беше от тип `unsigned short`:

<pre style="font-family: monospace; line-height: 1.2;">
┌───┐┌───┐┌───┐┌───┐
│'n'││'i'││'c'││'o'│  // байтове 0-3, начало на полето name
└───┘└───┘└───┘└───┘
┌───┐┌───┐┌───┐┌───┐
│\0 ││\0 ││\0 ││\0 │  // байтове 4-7, представете си, че има единични кавички, нямам място за тях
└───┘└───┘└───┘└───┘
        ...
┌───┐┌───┐┌───┐┌───┐
│\0 ││ # ││15 ││00 │  // байтове 128-131  (*)
└───┘└───┘└───┘└───┘
┌───┐┌───┐┌───┐┌───┐
│'0'││'1'││'2'││'3'│  // байтове 132-135, начало на полето fn
└───┘└───┘└───┘└───┘
┌───┐┌───┐┌───┐┌───┐
│'4'││'5'││'6'││'7'│  // байтове 136-139
└───┘└───┘└───┘└───┘
┌───┐┌───┐┌───┐┌───┐
│'8'││'9'││\0 ││ # │  // байтове 140-143
└───┘└───┘└───┘└───┘
</pre>

Разликата с горното представяне (с `unsigned int` вместо `unsigned short int`) се състои в
реда `(*)`. Тъй като `alignof(unsigned short int) == 2`, то полето `age` трябва да започва на
адрес, който е кратен на 2. За някакъв базов адрес `<addr>` (имаме предвид адреса, на който
е записан самият обект) виждаме, че `<addr> + 130` е кратно на 2, където 130 е отместването на `age` спрямо
базовия адрес (вижте диаграмата). Тогава можем да "поберем" това поле в оставащите 3 байта, които иначе биха
били padding.

*Въпрос*: Защо следното не е валидно?

```cpp
struct Foo {
  int x, y;
  Foo foo;
};
```

*Въпрос*: Колко е размерът на следната структура? Защо?

```cpp
struct Bar {};
```

### Анонимни структури

Структурите, подобно на енумерациите, могат да бъдат анонимни,
с разликата че задължително трябва да имаме поне един *обект*
от тази структура:

```cpp
struct {
  // някакви полета, указващи конфигурация, тук
} default_config;
```

---

## Обединения (unions)

Обединенията в C++ ни позволяват да представим една и съща памет
като стойност от няколко различни типа, като всеки от тези типове
ни задава някакъв конкретен начин да интерпретираме дадената памет.

Синтаксисът е следният:

```cpp
union {<име_на_тип>} {
  // поле_1;
  // поле_2;
  // ...
  // поле_n;
} {<име_на_променлива>};
```

Големината на обединение е големината на най-голямото му поле
(т.е. полетата могат да бъдат с различни размери и оттам - с различни типове).

Например, обединенията са начин за представяне на "избор"
между два типа. Разгледайте следния пример:

```cpp
union IntOrFloat {
  int   ival;
  float fval;
} value;
```

Тогава `value` има размер общо 4 байта, които можем да разглеждаме или като
`int`, или като `float`. Няма смисъл да разглеждаме тази памет и като двата
типа едновременно, понеже се представят по различен начин в паметта (т.е.
целичислени и числа с плаваща запетая). В някакъв аспект се опитваме да
симулираме динамично типизирани променливи в статично типизиран език.
Но сама по себе си горната конструкция не е особено полезна, тъй като
в даден момент не знаем какво има в нея - дали имаме цяло число, или
число с плаваща запетая. Очевидно ние бихме искали да знаем това,
защото числото `4` има съществено различни представяния спрямо това,
дали е `int` или `float`.

Можем да се справим с горния проблем, като обединим знанията си за горните
три начина за дефиниране на тип. Съобразяваме, че ако пазим кой тип данни
се съдържа в дадена променлива от тип `IntOrFloat`, т.е. нейният
*активен тип*, ще имаме достатъчно информация, за да избегнем грешно
интерпретиране на байтовете в обединението, което би било недефинирано поведение.
Това може да стане така:

```cpp
struct IntOrFloat {
  enum class ActiveType {
    INT, FLOAT
  } activeType;

  union { // тук може и да укажем име на тип, а може и да не
    int   ival;
    float fval;
  } value;
};
```

Тук самата структура е именувана `IntOrFloat`, а не - обединението.

Директно създаваме стойности от тип `ActiveType` (съответно - `activeType`)
и стойност на обединението (`value`), което обаче няма тип. Това се нарича
анонимно обединение. В случая можехме да напишем и име на някакъв тип,
но не е необходимо, тъй като самият тип няма да бъде ключов за достъпването
на стойностите на обединението (`ival` и `fval`).

Тогава обект от горната структура можем да създадем по следния начин:

```cpp
IntOrFloat iof{ .activeType = IntOrFloat::ActiveType::FLOAT,
                .value = { .fval = 4 } };
```

Тук е удобно да използваме designated initialisation, тъй като трябва
*екплицитно* да укажем, че искаме да инициализираме `value` със стойност
от тип `float`, което става именно посредством полето `fval`.
Друг вариант е първо да създадем обекта и чак след това да инициализираме
полетата му поотделно.

Забележете каква е областта на видимост на стойностите `INT` и `FLOAT` -
тя може да бъде с произволна вложеност. Тъй като сме използвали `enum class`,
трябва да използваме `ActiveType::FLOAT`, за да достъпим стойността, и нещо повече -
тъй като сме дефинирали `ActiveType` в структурата `IntOrFloat`, то нейната област
на видимост е именно в самата структура (в горните примери сме имали глобална видимост).
Така че допълнително първо трябва да "влезем" в областта на видимост на `IntOrFloat`.

И можем да напишем следната функция:

```cpp
void print(IntOrFloat const &iof) {
  switch (iof.activeType) {

    case IntOrFloat::ActiveType::INT:
      std::cout << iof.value.ival;
      return;

    case IntOrFloat::ActiveType::FLOAT:
      std::cout << iof.value.fval;
      return;
  }

  std::cout << "invalid type in object";
}
```

### (Допълнително) Ленива инициализация и placement new

TODO
